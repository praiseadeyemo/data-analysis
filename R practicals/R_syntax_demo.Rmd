---
title: "Intro to R Day 1 - R syntax"
output:
  html_document:
    df_print: paged
    theme: spacelab
---

<!-- html_notebook:
    toc: yes
    theme: spacelab -->

```{r, include=FALSE}
knitr::opts_chunk$set(
  #results = 'hide'
  results = 'markup'
)
```

## Aims of this notebook

This notebook is designed to introduce you to the R programming language. We will cover the following topics:

- What is a programming language?
- Some sources & references on the R programming language
- Basic syntax & programming concepts in R

## What is a programming language?

A human readable, standardised, high-level language that computers can translate into a set of low-level instructions to take inputs, transform them, and produce outputs. Programming languages vary in syntax: C, Java, Python, R, and Julia all have different syntaxes to suit different use cases. Programming languages are considered "Turing complete" when, in principle, they could be used to solve any computation problem regardless of speed and memory requirements. C, Java, Python, R, and Julia are all considered Turing complete. The choice of the programming language is a matter of convenience, power and aesthetics...

Writing programs using programming languages can be done in any plain text editor, including the terminal. For convenience, you may use a text editor (**not** a *word* processor!) with added features like built-in code execution, output rendering inline and/or in panes, etc. RStudio, Visual Studio Code, Sublime Text are all interchangeable text editors when it comes to writing and executing R programs.

### Some sources & references on the R programming language

-   [Hands-On Programming with R](https://rstudio-education.github.io/hopr/)
-   [Data Science lectures & tutorials](https://www.datamentor.io/)
-   [Good enough practices in scientific computing](https://github.com/swcarpentry/good-enough-practices-in-scientific-computing/blob/gh-pages/good-enough-practices-for-scientific-computing.pdf)
-   [R for Data Science](http://r4ds.had.co.nz/)

## Packages we will need

```{r message=FALSE, warning=FALSE}
library(docstring)
library(dplyr)
library(ggplot2)
library(ggfortify)
```

## Programming concepts

### Variables

Variables are names that refer to values. In R, variables are assigned using the `<-` operator. The value of a variable can be changed by re-assigning it.

```{r}
x <- 1
x
x <- 2
x
```

### Data types

Data types are the different kinds of values that can be stored and manipulated in a program. In R, the main data types are: numeric, character, logical, and complex. The `typeof()` function can be used to check the type of a value.

```{r}
typeof(TRUE)
```

```{r}
typeof(1) # not an integer for R (!)
```

```{r}
typeof(integer(1))
```

```{r}
typeof("1")
```

```{r}
class(TRUE)
class(1)
class(integer(1))
class("1") # note the double quotes
```

```{r}
x <- list("a",c(3, 5, 7)) # make a list of diverse types
class(x)
class(x)<-"myclass" # define a new class for this object
class(x)
```

```{r}
typeof(x)
#typeof(x) <- "mytype" # types are immutable
```

Some special types:

```{r}
d <- Sys.Date() # get date from the computer's system
d
```

```{r}
typeof(d) # not a character despite the quotes (!)
```

### Classes

Classes are a way to group objects of the same type. Classes are defined by the programmer, and can be used to define new types of objects. Classes are defined using the `class()` function. The `class()` function can also be used to check the class of an object.

```{r}
class(1)
class("1")
class(TRUE)
```

### Factors

```{r}
sex <- c("male", "female", "female", "male")
class(sex)
```

```{r}
typeof("female")
```

Here, R sees `sex` as of type `character`, which is not what we need.

```{r}
sex <- factor(c("male", "female", "female", "male")) # need to explicitly specify if we want this to be treated as a categorical variable
class(sex)
```

### Coercion & type conversion

If we already have an object of the wrong type, we can convert it with `as.<type>`:

```{r}
sex <- c("male", "female", "female", "male")
class(sex)
```

Let's convert that to a `factor`:

```{r}
sex <- as.factor(sex)
class(sex)
```

```{r}
typeof(1)
as.logical(1)
as.character(1)
as.numeric(TRUE)
typeof(as.numeric(TRUE))
class(as.numeric(TRUE))
```

## Data structures

### Atomic vector

An atomic vector is a simple one-dimensional vector, or one-dimensional array, of data of length ≥ 1. A vector can contain only one type of data

```{r}
die <- 1:6  # shorthand for c(1, 2, 3, 4, 5, 6)
die
is.vector(die)
```

```{r}
four <- 4
is.vector(four)
```

A vector is a one-dimensional list.

### Matrices

In R, a matrix is a two-dimensional array.

```{r}
m <- matrix(die, nrow = 3)
m
dim(m)
```

The dimensions of a matrix are listed "rows first", but the contents are filled "column by column". If you would rather fill the matrix row by row, specify `byrow`:

```{r}
m <- matrix(die, nrow = 3, byrow = TRUE)
m
```

```{r}
attributes(m)
```

Note that attributes of `die` were not inherited by `m`:

```{r}
attributes(die)
```

### Arrays

Arrays in R are n-dimensional arrays where n ≥ 3. As with atomic vectors and matrices, arrays contain elements of the same type, **column-wise**. Remember we saw:

```{r}
class(die)
```

Now, lets see:

```{r}
ar <- array(c("ace", "king", "queen", "jack", "ten", "nine", "eight", "seven", "six"), dim = c(4, 2, 3))
ar
```

Notice how R silently fills in unspecified elements of the array by recycling those we provided (!).

```{r}
attributes(ar)
```

```{r}
typeof(ar)
```

### Lists

Lists in R extend the concept of atomic vectors to encompass a wide range of objects. A list is a one-dimensional data structure that can contain diverse elements, including vectors, matrices, and even other lists.

```{r}
listylist <- list(10:70, list(TRUE, FALSE, TRUE, 10, "12"), "Hello world!")
listylist
```

The double brackets `[[1]]` denote the indices for each list item while single brackets denote which element of the list item is being displayed.

```{r}
class(listylist)
```

```{r}
dim(listylist) # no dim attribute of course
```

```{r}
length(listylist) # counts only root levels
```

### Data frames

A dataframe extends lists to 2D tables with columns and headers that resemble excel spreadsheets, each column of which can by of a different but single type.

```{r}
df <- data.frame(face = c("ace", 10, 7, "joker"),
                 suit = c("clubs", "clubs", "clubs", "hearts"),
                 value = c(1, 2, 3, 4.5),
                 red = c(TRUE, FALSE, FALSE, TRUE),
                 black = c(FALSE, TRUE, 1, FALSE))
df
```

Notice the the same silent column-wise type coercion.

```{r}
str(df)
```

So here too, the hierarchy of types applies:

logical → numeric (1, 0) → character

Another benefit over matrices is the ability to name each column:

```{r}
names(df) # return names of each column
```

Maybe surprisingly, data frame is a class of type list:

```{r}
print(c("Type:", typeof(df)), quote = F)
print(c("Class:", class(df)), quote = F)
```

### Functions

Functions are a way to package code for reuse. Functions take inputs, do something with them, and return outputs. Functions are defined using the `function()` keyword. Functions can be called by name, and their arguments can be specified by name or position.

```{r}
f <- function(x) {
  x^2
}
f(2)
f(3)
```

```{r}
g <- function(x, y) {
  x^y
}
g(2, 3)
g(3, 2)
```

## Importing functions for libaries (or packages)

You don't hve to write all your functions from scratch. R has a vast library of functions that you can import and use. You can import a library using the `library()` function. You can also import a specific function from a library using the `::` operator.

```{r}
library(dplyr)
```

This library is a collection of functions that make it easier to work with data frames. For example, the `select()` function can be used to select columns from a data frame.

For example:

```{r}
df <- data.frame(face = c("ace", 10, 7, "joker"),
                 suit = c("clubs", "clubs", "clubs", "hearts"),
                 value = c(1, 2, 3, 4.5),
                 red = c(TRUE, FALSE, FALSE, TRUE),
                 black = c(FALSE, TRUE, 1, FALSE))
df
```

```{r}
df_selected <- dplyr::select(df, face, suit)
df_selected
```

For the rest of this course, we will be using many different libraries. We will import them as needed. Remember to only import the specific libraries you need, as importing libraries can slow down your code. In addition, importing libraries can cause conflicts if two libraries have functions with the same name or if you have written a function with the same name. Therefore, **always import libraries at the beginning of your script or notebook**.